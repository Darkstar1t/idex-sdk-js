/* Generated by ts-generator ver. 0.0.8 */
/* tslint:disable */

import {
  ethers,
  EventFilter,
  Signer,
  BigNumber,
  BigNumberish,
  PopulatedTransaction,
} from 'ethers';
import {
  Contract,
  ContractTransaction,
  Overrides,
  PayableOverrides,
  CallOverrides,
} from '@ethersproject/contracts';
import { BytesLike } from '@ethersproject/bytes';
import { Listener, Provider } from '@ethersproject/providers';
import { FunctionFragment, EventFragment, Result } from '@ethersproject/abi';

interface ExchangeInterface extends ethers.utils.Interface {
  functions: {
    'removeAdmin()': FunctionFragment;
    'setAdmin(address)': FunctionFragment;
    'setCustodian(address)': FunctionFragment;
    'setChainPropagationPeriod(uint256)': FunctionFragment;
    'setFeeWallet(address)': FunctionFragment;
    'loadBalanceInAssetUnitsByAddress(address,address)': FunctionFragment;
    'loadBalanceInAssetUnitsBySymbol(address,string)': FunctionFragment;
    'loadBalanceInPipsByAddress(address,address)': FunctionFragment;
    'loadBalanceInPipsBySymbol(address,string)': FunctionFragment;
    'loadPartiallyFilledOrderQuantityInPips(bytes32)': FunctionFragment;
    'depositEther()': FunctionFragment;
    'depositTokenByAddress(address,uint256)': FunctionFragment;
    'depositTokenBySymbol(string,uint256)': FunctionFragment;
    'invalidateOrderNonce(uint128)': FunctionFragment;
    'withdraw(tuple)': FunctionFragment;
    'exitWallet()': FunctionFragment;
    'withdrawExit(address)': FunctionFragment;
    'executeTrade(tuple,tuple,tuple)': FunctionFragment;
    'registerToken(address,string,uint8)': FunctionFragment;
    'confirmTokenRegistration(address,string,uint8)': FunctionFragment;
    'loadAssetBySymbol(string,uint64)': FunctionFragment;
    'setDispatcher(address)': FunctionFragment;
    'removeDispatcher()': FunctionFragment;
  };

  encodeFunctionData(
    functionFragment: 'removeAdmin',
    values?: undefined,
  ): string;
  encodeFunctionData(functionFragment: 'setAdmin', values: [string]): string;
  encodeFunctionData(
    functionFragment: 'setCustodian',
    values: [string],
  ): string;
  encodeFunctionData(
    functionFragment: 'setChainPropagationPeriod',
    values: [BigNumberish],
  ): string;
  encodeFunctionData(
    functionFragment: 'setFeeWallet',
    values: [string],
  ): string;
  encodeFunctionData(
    functionFragment: 'loadBalanceInAssetUnitsByAddress',
    values: [string, string],
  ): string;
  encodeFunctionData(
    functionFragment: 'loadBalanceInAssetUnitsBySymbol',
    values: [string, string],
  ): string;
  encodeFunctionData(
    functionFragment: 'loadBalanceInPipsByAddress',
    values: [string, string],
  ): string;
  encodeFunctionData(
    functionFragment: 'loadBalanceInPipsBySymbol',
    values: [string, string],
  ): string;
  encodeFunctionData(
    functionFragment: 'loadPartiallyFilledOrderQuantityInPips',
    values: [BytesLike],
  ): string;
  encodeFunctionData(
    functionFragment: 'depositEther',
    values?: undefined,
  ): string;
  encodeFunctionData(
    functionFragment: 'depositTokenByAddress',
    values: [string, BigNumberish],
  ): string;
  encodeFunctionData(
    functionFragment: 'depositTokenBySymbol',
    values: [string, BigNumberish],
  ): string;
  encodeFunctionData(
    functionFragment: 'invalidateOrderNonce',
    values: [BigNumberish],
  ): string;
  encodeFunctionData(
    functionFragment: 'withdraw',
    values: [
      {
        withdrawalType: BigNumberish;
        nonce: BigNumberish;
        walletAddress: string;
        assetSymbol: string;
        assetAddress: string;
        quantityInPips: BigNumberish;
        gasFeeInPips: BigNumberish;
        autoDispatchEnabled: boolean;
        walletSignature: BytesLike;
      },
    ],
  ): string;
  encodeFunctionData(
    functionFragment: 'exitWallet',
    values?: undefined,
  ): string;
  encodeFunctionData(
    functionFragment: 'withdrawExit',
    values: [string],
  ): string;
  encodeFunctionData(
    functionFragment: 'executeTrade',
    values: [
      {
        signatureHashVersion: BigNumberish;
        nonce: BigNumberish;
        walletAddress: string;
        orderType: BigNumberish;
        side: BigNumberish;
        quantityInPips: BigNumberish;
        quoteOrderQuantityInPips: BigNumberish;
        limitPriceInPips: BigNumberish;
        stopPriceInPips: BigNumberish;
        clientOrderId: string;
        timeInForce: BigNumberish;
        selfTradePrevention: BigNumberish;
        cancelAfter: BigNumberish;
        walletSignature: BytesLike;
      },
      {
        signatureHashVersion: BigNumberish;
        nonce: BigNumberish;
        walletAddress: string;
        orderType: BigNumberish;
        side: BigNumberish;
        quantityInPips: BigNumberish;
        quoteOrderQuantityInPips: BigNumberish;
        limitPriceInPips: BigNumberish;
        stopPriceInPips: BigNumberish;
        clientOrderId: string;
        timeInForce: BigNumberish;
        selfTradePrevention: BigNumberish;
        cancelAfter: BigNumberish;
        walletSignature: BytesLike;
      },
      {
        baseAssetSymbol: string;
        quoteAssetSymbol: string;
        baseAssetAddress: string;
        quoteAssetAddress: string;
        grossBaseQuantityInPips: BigNumberish;
        grossQuoteQuantityInPips: BigNumberish;
        netBaseQuantityInPips: BigNumberish;
        netQuoteQuantityInPips: BigNumberish;
        makerFeeAssetAddress: string;
        takerFeeAssetAddress: string;
        makerFeeQuantityInPips: BigNumberish;
        takerFeeQuantityInPips: BigNumberish;
        priceInPips: BigNumberish;
        makerSide: BigNumberish;
      },
    ],
  ): string;
  encodeFunctionData(
    functionFragment: 'registerToken',
    values: [string, string, BigNumberish],
  ): string;
  encodeFunctionData(
    functionFragment: 'confirmTokenRegistration',
    values: [string, string, BigNumberish],
  ): string;
  encodeFunctionData(
    functionFragment: 'loadAssetBySymbol',
    values: [string, BigNumberish],
  ): string;
  encodeFunctionData(
    functionFragment: 'setDispatcher',
    values: [string],
  ): string;
  encodeFunctionData(
    functionFragment: 'removeDispatcher',
    values?: undefined,
  ): string;

  decodeFunctionResult(
    functionFragment: 'removeAdmin',
    data: BytesLike,
  ): Result;
  decodeFunctionResult(functionFragment: 'setAdmin', data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: 'setCustodian',
    data: BytesLike,
  ): Result;
  decodeFunctionResult(
    functionFragment: 'setChainPropagationPeriod',
    data: BytesLike,
  ): Result;
  decodeFunctionResult(
    functionFragment: 'setFeeWallet',
    data: BytesLike,
  ): Result;
  decodeFunctionResult(
    functionFragment: 'loadBalanceInAssetUnitsByAddress',
    data: BytesLike,
  ): Result;
  decodeFunctionResult(
    functionFragment: 'loadBalanceInAssetUnitsBySymbol',
    data: BytesLike,
  ): Result;
  decodeFunctionResult(
    functionFragment: 'loadBalanceInPipsByAddress',
    data: BytesLike,
  ): Result;
  decodeFunctionResult(
    functionFragment: 'loadBalanceInPipsBySymbol',
    data: BytesLike,
  ): Result;
  decodeFunctionResult(
    functionFragment: 'loadPartiallyFilledOrderQuantityInPips',
    data: BytesLike,
  ): Result;
  decodeFunctionResult(
    functionFragment: 'depositEther',
    data: BytesLike,
  ): Result;
  decodeFunctionResult(
    functionFragment: 'depositTokenByAddress',
    data: BytesLike,
  ): Result;
  decodeFunctionResult(
    functionFragment: 'depositTokenBySymbol',
    data: BytesLike,
  ): Result;
  decodeFunctionResult(
    functionFragment: 'invalidateOrderNonce',
    data: BytesLike,
  ): Result;
  decodeFunctionResult(functionFragment: 'withdraw', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'exitWallet', data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: 'withdrawExit',
    data: BytesLike,
  ): Result;
  decodeFunctionResult(
    functionFragment: 'executeTrade',
    data: BytesLike,
  ): Result;
  decodeFunctionResult(
    functionFragment: 'registerToken',
    data: BytesLike,
  ): Result;
  decodeFunctionResult(
    functionFragment: 'confirmTokenRegistration',
    data: BytesLike,
  ): Result;
  decodeFunctionResult(
    functionFragment: 'loadAssetBySymbol',
    data: BytesLike,
  ): Result;
  decodeFunctionResult(
    functionFragment: 'setDispatcher',
    data: BytesLike,
  ): Result;
  decodeFunctionResult(
    functionFragment: 'removeDispatcher',
    data: BytesLike,
  ): Result;

  events: {
    'ChainPropagationPeriodChanged(uint256,uint256)': EventFragment;
    'Deposited(uint64,address,address,string,string,uint64,uint64,uint256)': EventFragment;
    'DispatcherChanged(address,address)': EventFragment;
    'FeeWalletChanged(address,address)': EventFragment;
    'OrderNonceInvalidated(address,uint128,uint128,uint256)': EventFragment;
    'TokenRegistered(address,string,uint8)': EventFragment;
    'TokenRegistrationConfirmed(address,string,uint8)': EventFragment;
    'TradeExecuted(address,address,string,string,string,string,uint64,uint64,uint64,bytes32,bytes32)': EventFragment;
    'WalletExitWithdrawn(address,address,string,uint64,uint64,uint256)': EventFragment;
    'WalletExited(address,uint256)': EventFragment;
    'Withdrawn(address,address,string,uint64,uint64,uint256)': EventFragment;
  };

  getEvent(
    nameOrSignatureOrTopic: 'ChainPropagationPeriodChanged',
  ): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'Deposited'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'DispatcherChanged'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'FeeWalletChanged'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'OrderNonceInvalidated'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'TokenRegistered'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'TokenRegistrationConfirmed'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'TradeExecuted'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'WalletExitWithdrawn'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'WalletExited'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'Withdrawn'): EventFragment;
}

export class Exchange extends Contract {
  connect(signerOrProvider: Signer | Provider | string): this;

  attach(addressOrName: string): this;

  deployed(): Promise<this>;

  on(event: EventFilter | string, listener: Listener): this;

  once(event: EventFilter | string, listener: Listener): this;

  addListener(eventName: EventFilter | string, listener: Listener): this;

  removeAllListeners(eventName: EventFilter | string): this;

  removeListener(eventName: any, listener: Listener): this;

  interface: ExchangeInterface;

  functions: {
    /**
     * Load a wallet's balance by asset address, in asset units
     * @param assetAddress The asset address to load the wallet's balance for
     * @param wallet The wallet address to load the balance for. Can be different from `msg.sender`
     */
    loadBalanceInAssetUnitsByAddress(
      wallet: string,
      assetAddress: string,
      overrides?: CallOverrides,
    ): Promise<{
      0: BigNumber;
    }>;

    /**
     * Load a wallet's balance by asset address, in asset units
     * @param assetSymbol The asset symbol to load the wallet's balance for
     * @param wallet The wallet address to load the balance for. Can be different from `msg.sender`
     */
    loadBalanceInAssetUnitsBySymbol(
      wallet: string,
      assetSymbol: string,
      overrides?: CallOverrides,
    ): Promise<{
      0: BigNumber;
    }>;

    /**
     * Load a wallet's balance by asset address, in pips
     * @param assetAddress The asset address to load the wallet's balance for
     * @param wallet The wallet address to load the balance for. Can be different from `msg.sender`
     */
    loadBalanceInPipsByAddress(
      wallet: string,
      assetAddress: string,
      overrides?: CallOverrides,
    ): Promise<{
      0: BigNumber;
    }>;

    /**
     * Load a wallet's balance by asset symbol, in pips
     * @param assetSymbol The asset symbol to load the wallet's balance for
     * @param wallet The wallet address to load the balance for. Can be different from `msg.sender`
     */
    loadBalanceInPipsBySymbol(
      wallet: string,
      assetSymbol: string,
      overrides?: CallOverrides,
    ): Promise<{
      0: BigNumber;
    }>;

    /**
     * Deposit ETH
     */
    depositEther(overrides?: PayableOverrides): Promise<ContractTransaction>;

    /**
     * Deposit `IERC20` compliant tokens
     * @param quantityInAssetUnits The quantity to deposit. The sending wallet must first call the `approve` method on the token contract for at least this quantity first
     * @param tokenAddress The token contract address
     */
    depositTokenByAddress(
      tokenAddress: string,
      quantityInAssetUnits: BigNumberish,
      overrides?: Overrides,
    ): Promise<ContractTransaction>;

    /**
     * Deposit `IERC20` compliant tokens
     * @param assetSymbol The case-sensitive symbol string for the token
     * @param quantityInAssetUnits The quantity to deposit. The sending wallet must first call the `approve` method on the token contract for at least this quantity first
     */
    depositTokenBySymbol(
      assetSymbol: string,
      quantityInAssetUnits: BigNumberish,
      overrides?: Overrides,
    ): Promise<ContractTransaction>;

    /**
     * Permanently flags the sending wallet as exited, immediately disabling deposits upon mining. After the Chain Propagation Period passes trades and withdrawals are also disabled for the wallet, and assets may then be withdrawn one at a time via `withdrawExit`
     */
    exitWallet(overrides?: Overrides): Promise<ContractTransaction>;

    /**
     * Withdraw the entire balance of an asset for an exited wallet. The Chain Propagation Period must have already passed since calling `exitWallet` on `assetAddress`
     * @param assetAddress The address of the asset to withdraw
     */
    withdrawExit(
      assetAddress: string,
      overrides?: Overrides,
    ): Promise<ContractTransaction>;
  };

  /**
   * Load a wallet's balance by asset address, in asset units
   * @param assetAddress The asset address to load the wallet's balance for
   * @param wallet The wallet address to load the balance for. Can be different from `msg.sender`
   */
  loadBalanceInAssetUnitsByAddress(
    wallet: string,
    assetAddress: string,
    overrides?: CallOverrides,
  ): Promise<BigNumber>;

  /**
   * Load a wallet's balance by asset address, in asset units
   * @param assetSymbol The asset symbol to load the wallet's balance for
   * @param wallet The wallet address to load the balance for. Can be different from `msg.sender`
   */
  loadBalanceInAssetUnitsBySymbol(
    wallet: string,
    assetSymbol: string,
    overrides?: CallOverrides,
  ): Promise<BigNumber>;

  /**
   * Load a wallet's balance by asset address, in pips
   * @param assetAddress The asset address to load the wallet's balance for
   * @param wallet The wallet address to load the balance for. Can be different from `msg.sender`
   */
  loadBalanceInPipsByAddress(
    wallet: string,
    assetAddress: string,
    overrides?: CallOverrides,
  ): Promise<BigNumber>;

  /**
   * Load a wallet's balance by asset symbol, in pips
   * @param assetSymbol The asset symbol to load the wallet's balance for
   * @param wallet The wallet address to load the balance for. Can be different from `msg.sender`
   */
  loadBalanceInPipsBySymbol(
    wallet: string,
    assetSymbol: string,
    overrides?: CallOverrides,
  ): Promise<BigNumber>;

  /**
   * Deposit ETH
   */
  depositEther(overrides?: PayableOverrides): Promise<ContractTransaction>;

  /**
   * Deposit `IERC20` compliant tokens
   * @param quantityInAssetUnits The quantity to deposit. The sending wallet must first call the `approve` method on the token contract for at least this quantity first
   * @param tokenAddress The token contract address
   */
  depositTokenByAddress(
    tokenAddress: string,
    quantityInAssetUnits: BigNumberish,
    overrides?: Overrides,
  ): Promise<ContractTransaction>;

  /**
   * Deposit `IERC20` compliant tokens
   * @param assetSymbol The case-sensitive symbol string for the token
   * @param quantityInAssetUnits The quantity to deposit. The sending wallet must first call the `approve` method on the token contract for at least this quantity first
   */
  depositTokenBySymbol(
    assetSymbol: string,
    quantityInAssetUnits: BigNumberish,
    overrides?: Overrides,
  ): Promise<ContractTransaction>;

  /**
   * Permanently flags the sending wallet as exited, immediately disabling deposits upon mining. After the Chain Propagation Period passes trades and withdrawals are also disabled for the wallet, and assets may then be withdrawn one at a time via `withdrawExit`
   */
  exitWallet(overrides?: Overrides): Promise<ContractTransaction>;

  /**
   * Withdraw the entire balance of an asset for an exited wallet. The Chain Propagation Period must have already passed since calling `exitWallet` on `assetAddress`
   * @param assetAddress The address of the asset to withdraw
   */
  withdrawExit(
    assetAddress: string,
    overrides?: Overrides,
  ): Promise<ContractTransaction>;

  /**
   * Clears the currently set whitelisted dispatcher wallet, effectively disabling calling the `executeTrade` and `withdraw` functions until a new wallet is set with `setDispatcher`
   */
  removeDispatcher(overrides?: Overrides): Promise<ContractTransaction>;

  callStatic: {
    /**
     * Load a wallet's balance by asset address, in asset units
     * @param assetAddress The asset address to load the wallet's balance for
     * @param wallet The wallet address to load the balance for. Can be different from `msg.sender`
     */
    loadBalanceInAssetUnitsByAddress(
      wallet: string,
      assetAddress: string,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    /**
     * Load a wallet's balance by asset address, in asset units
     * @param assetSymbol The asset symbol to load the wallet's balance for
     * @param wallet The wallet address to load the balance for. Can be different from `msg.sender`
     */
    loadBalanceInAssetUnitsBySymbol(
      wallet: string,
      assetSymbol: string,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    /**
     * Load a wallet's balance by asset address, in pips
     * @param assetAddress The asset address to load the wallet's balance for
     * @param wallet The wallet address to load the balance for. Can be different from `msg.sender`
     */
    loadBalanceInPipsByAddress(
      wallet: string,
      assetAddress: string,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    /**
     * Load a wallet's balance by asset symbol, in pips
     * @param assetSymbol The asset symbol to load the wallet's balance for
     * @param wallet The wallet address to load the balance for. Can be different from `msg.sender`
     */
    loadBalanceInPipsBySymbol(
      wallet: string,
      assetSymbol: string,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    /**
     * Deposit ETH
     */
    depositEther(overrides?: PayableOverrides): Promise<void>;

    /**
     * Deposit `IERC20` compliant tokens
     * @param quantityInAssetUnits The quantity to deposit. The sending wallet must first call the `approve` method on the token contract for at least this quantity first
     * @param tokenAddress The token contract address
     */
    depositTokenByAddress(
      tokenAddress: string,
      quantityInAssetUnits: BigNumberish,
      overrides?: Overrides,
    ): Promise<void>;

    /**
     * Deposit `IERC20` compliant tokens
     * @param assetSymbol The case-sensitive symbol string for the token
     * @param quantityInAssetUnits The quantity to deposit. The sending wallet must first call the `approve` method on the token contract for at least this quantity first
     */
    depositTokenBySymbol(
      assetSymbol: string,
      quantityInAssetUnits: BigNumberish,
      overrides?: Overrides,
    ): Promise<void>;

    /**
     * Permanently flags the sending wallet as exited, immediately disabling deposits upon mining. After the Chain Propagation Period passes trades and withdrawals are also disabled for the wallet, and assets may then be withdrawn one at a time via `withdrawExit`
     */
    exitWallet(overrides?: Overrides): Promise<void>;

    /**
     * Withdraw the entire balance of an asset for an exited wallet. The Chain Propagation Period must have already passed since calling `exitWallet` on `assetAddress`
     * @param assetAddress The address of the asset to withdraw
     */
    withdrawExit(assetAddress: string, overrides?: Overrides): Promise<void>;
  };

  filters: {
    TokenRegistered(
      assetAddress: string | null,
      assetSymbol: null,
      decimals: null,
    ): EventFilter;

    TokenRegistrationConfirmed(
      assetAddress: string | null,
      assetSymbol: null,
      decimals: null,
    ): EventFilter;

    WalletExitWithdrawn(
      wallet: string | null,
      assetAddress: string | null,
      assetSymbol: null,
      quantityInPips: null,
      newExchangeBalanceInPips: null,
      newExchangeBalanceInAssetUnits: null,
    ): EventFilter;

    WalletExited(
      wallet: string | null,
      effectiveBlockNumber: null,
    ): EventFilter;

    Withdrawn(
      wallet: string | null,
      assetAddress: string | null,
      assetSymbol: null,
      quantityInPips: null,
      newExchangeBalanceInPips: null,
      newExchangeBalanceInAssetUnits: null,
    ): EventFilter;
  };

  estimateGas: {
    /**
     * Load a wallet's balance by asset address, in asset units
     * @param assetAddress The asset address to load the wallet's balance for
     * @param wallet The wallet address to load the balance for. Can be different from `msg.sender`
     */
    loadBalanceInAssetUnitsByAddress(
      wallet: string,
      assetAddress: string,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    /**
     * Load a wallet's balance by asset address, in asset units
     * @param assetSymbol The asset symbol to load the wallet's balance for
     * @param wallet The wallet address to load the balance for. Can be different from `msg.sender`
     */
    loadBalanceInAssetUnitsBySymbol(
      wallet: string,
      assetSymbol: string,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    /**
     * Load a wallet's balance by asset address, in pips
     * @param assetAddress The asset address to load the wallet's balance for
     * @param wallet The wallet address to load the balance for. Can be different from `msg.sender`
     */
    loadBalanceInPipsByAddress(
      wallet: string,
      assetAddress: string,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    /**
     * Load a wallet's balance by asset symbol, in pips
     * @param assetSymbol The asset symbol to load the wallet's balance for
     * @param wallet The wallet address to load the balance for. Can be different from `msg.sender`
     */
    loadBalanceInPipsBySymbol(
      wallet: string,
      assetSymbol: string,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    /**
     * Deposit ETH
     */
    depositEther(overrides?: PayableOverrides): Promise<BigNumber>;

    /**
     * Deposit `IERC20` compliant tokens
     * @param quantityInAssetUnits The quantity to deposit. The sending wallet must first call the `approve` method on the token contract for at least this quantity first
     * @param tokenAddress The token contract address
     */
    depositTokenByAddress(
      tokenAddress: string,
      quantityInAssetUnits: BigNumberish,
      overrides?: Overrides,
    ): Promise<BigNumber>;

    /**
     * Deposit `IERC20` compliant tokens
     * @param assetSymbol The case-sensitive symbol string for the token
     * @param quantityInAssetUnits The quantity to deposit. The sending wallet must first call the `approve` method on the token contract for at least this quantity first
     */
    depositTokenBySymbol(
      assetSymbol: string,
      quantityInAssetUnits: BigNumberish,
      overrides?: Overrides,
    ): Promise<BigNumber>;

    /**
     * Permanently flags the sending wallet as exited, immediately disabling deposits upon mining. After the Chain Propagation Period passes trades and withdrawals are also disabled for the wallet, and assets may then be withdrawn one at a time via `withdrawExit`
     */
    exitWallet(overrides?: Overrides): Promise<BigNumber>;

    /**
     * Withdraw the entire balance of an asset for an exited wallet. The Chain Propagation Period must have already passed since calling `exitWallet` on `assetAddress`
     * @param assetAddress The address of the asset to withdraw
     */
    withdrawExit(
      assetAddress: string,
      overrides?: Overrides,
    ): Promise<BigNumber>;
  };

  populateTransaction: {
    /**
     * Load a wallet's balance by asset address, in asset units
     * @param assetAddress The asset address to load the wallet's balance for
     * @param wallet The wallet address to load the balance for. Can be different from `msg.sender`
     */
    loadBalanceInAssetUnitsByAddress(
      wallet: string,
      assetAddress: string,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    /**
     * Load a wallet's balance by asset address, in asset units
     * @param assetSymbol The asset symbol to load the wallet's balance for
     * @param wallet The wallet address to load the balance for. Can be different from `msg.sender`
     */
    loadBalanceInAssetUnitsBySymbol(
      wallet: string,
      assetSymbol: string,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    /**
     * Load a wallet's balance by asset address, in pips
     * @param assetAddress The asset address to load the wallet's balance for
     * @param wallet The wallet address to load the balance for. Can be different from `msg.sender`
     */
    loadBalanceInPipsByAddress(
      wallet: string,
      assetAddress: string,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    /**
     * Load a wallet's balance by asset symbol, in pips
     * @param assetSymbol The asset symbol to load the wallet's balance for
     * @param wallet The wallet address to load the balance for. Can be different from `msg.sender`
     */
    loadBalanceInPipsBySymbol(
      wallet: string,
      assetSymbol: string,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    /**
     * Deposit ETH
     */
    depositEther(overrides?: PayableOverrides): Promise<PopulatedTransaction>;

    /**
     * Deposit `IERC20` compliant tokens
     * @param quantityInAssetUnits The quantity to deposit. The sending wallet must first call the `approve` method on the token contract for at least this quantity first
     * @param tokenAddress The token contract address
     */
    depositTokenByAddress(
      tokenAddress: string,
      quantityInAssetUnits: BigNumberish,
      overrides?: Overrides,
    ): Promise<PopulatedTransaction>;

    /**
     * Deposit `IERC20` compliant tokens
     * @param assetSymbol The case-sensitive symbol string for the token
     * @param quantityInAssetUnits The quantity to deposit. The sending wallet must first call the `approve` method on the token contract for at least this quantity first
     */
    depositTokenBySymbol(
      assetSymbol: string,
      quantityInAssetUnits: BigNumberish,
      overrides?: Overrides,
    ): Promise<PopulatedTransaction>;

    /**
     * Invalidate all order nonces with a timestampInMs lower than the one provided
     * @param nonce A Version 1 UUID. After calling and once the Chain Propagation Period has elapsed, `executeTrade` will reject order nonces from this wallet with a timestampInMs component lower than the one provided
     */
    invalidateOrderNonce(
      nonce: BigNumberish,
      overrides?: Overrides,
    ): Promise<PopulatedTransaction>;

    /**
     * Permanently flags the sending wallet as exited, immediately disabling deposits upon mining. After the Chain Propagation Period passes trades and withdrawals are also disabled for the wallet, and assets may then be withdrawn one at a time via `withdrawExit`
     */
    exitWallet(overrides?: Overrides): Promise<PopulatedTransaction>;

    /**
     * Withdraw the entire balance of an asset for an exited wallet. The Chain Propagation Period must have already passed since calling `exitWallet` on `assetAddress`
     * @param assetAddress The address of the asset to withdraw
     */
    withdrawExit(
      assetAddress: string,
      overrides?: Overrides,
    ): Promise<PopulatedTransaction>;
  };
}
