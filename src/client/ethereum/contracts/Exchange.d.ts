/* Generated by ts-generator ver. 0.0.8 */
/* tslint:disable */

import {
  ethers,
  EventFilter,
  Signer,
  BigNumber,
  BigNumberish,
  PopulatedTransaction,
} from 'ethers';
import {
  Contract,
  ContractTransaction,
  Overrides,
  PayableOverrides,
  CallOverrides,
} from '@ethersproject/contracts';
import { BytesLike } from '@ethersproject/bytes';
import { Listener, Provider } from '@ethersproject/providers';
import { FunctionFragment, EventFragment, Result } from '@ethersproject/abi';

interface ExchangeInterface extends ethers.utils.Interface {
  functions: {
    'removeAdmin()': FunctionFragment;
    'setAdmin(address)': FunctionFragment;
    'setCustodian(address)': FunctionFragment;
    'setChainPropagationPeriod(uint256)': FunctionFragment;
    'setFeeWallet(address)': FunctionFragment;
    'loadBalanceInAssetUnitsByAddress(address,address)': FunctionFragment;
    'loadBalanceInAssetUnitsBySymbol(address,string)': FunctionFragment;
    'loadBalanceInPipsByAddress(address,address)': FunctionFragment;
    'loadBalanceInPipsBySymbol(address,string)': FunctionFragment;
    'loadPartiallyFilledOrderQuantityInPips(bytes32)': FunctionFragment;
    'depositEther()': FunctionFragment;
    'depositTokenByAddress(address,uint256)': FunctionFragment;
    'depositTokenBySymbol(string,uint256)': FunctionFragment;
    'invalidateOrderNonce(uint128)': FunctionFragment;
    'withdraw(tuple)': FunctionFragment;
    'exitWallet()': FunctionFragment;
    'withdrawExit(address)': FunctionFragment;
    'executeTrade(tuple,tuple,tuple)': FunctionFragment;
    'registerToken(address,string,uint8)': FunctionFragment;
    'confirmTokenRegistration(address,string,uint8)': FunctionFragment;
    'loadAssetBySymbol(string,uint64)': FunctionFragment;
    'setDispatcher(address)': FunctionFragment;
    'removeDispatcher()': FunctionFragment;
  };

  encodeFunctionData(
    functionFragment: 'removeAdmin',
    values?: undefined,
  ): string;
  encodeFunctionData(functionFragment: 'setAdmin', values: [string]): string;
  encodeFunctionData(
    functionFragment: 'setCustodian',
    values: [string],
  ): string;
  encodeFunctionData(
    functionFragment: 'setChainPropagationPeriod',
    values: [BigNumberish],
  ): string;
  encodeFunctionData(
    functionFragment: 'setFeeWallet',
    values: [string],
  ): string;
  encodeFunctionData(
    functionFragment: 'loadBalanceInAssetUnitsByAddress',
    values: [string, string],
  ): string;
  encodeFunctionData(
    functionFragment: 'loadBalanceInAssetUnitsBySymbol',
    values: [string, string],
  ): string;
  encodeFunctionData(
    functionFragment: 'loadBalanceInPipsByAddress',
    values: [string, string],
  ): string;
  encodeFunctionData(
    functionFragment: 'loadBalanceInPipsBySymbol',
    values: [string, string],
  ): string;
  encodeFunctionData(
    functionFragment: 'loadPartiallyFilledOrderQuantityInPips',
    values: [BytesLike],
  ): string;
  encodeFunctionData(
    functionFragment: 'depositEther',
    values?: undefined,
  ): string;
  encodeFunctionData(
    functionFragment: 'depositTokenByAddress',
    values: [string, BigNumberish],
  ): string;
  encodeFunctionData(
    functionFragment: 'depositTokenBySymbol',
    values: [string, BigNumberish],
  ): string;
  encodeFunctionData(
    functionFragment: 'invalidateOrderNonce',
    values: [BigNumberish],
  ): string;
  encodeFunctionData(
    functionFragment: 'withdraw',
    values: [
      {
        withdrawalType: BigNumberish;
        nonce: BigNumberish;
        walletAddress: string;
        assetSymbol: string;
        assetAddress: string;
        quantityInPips: BigNumberish;
        gasFeeInPips: BigNumberish;
        autoDispatchEnabled: boolean;
        walletSignature: BytesLike;
      },
    ],
  ): string;
  encodeFunctionData(
    functionFragment: 'exitWallet',
    values?: undefined,
  ): string;
  encodeFunctionData(
    functionFragment: 'withdrawExit',
    values: [string],
  ): string;
  encodeFunctionData(
    functionFragment: 'executeTrade',
    values: [
      {
        signatureHashVersion: BigNumberish;
        nonce: BigNumberish;
        walletAddress: string;
        orderType: BigNumberish;
        side: BigNumberish;
        quantityInPips: BigNumberish;
        quoteOrderQuantityInPips: BigNumberish;
        limitPriceInPips: BigNumberish;
        stopPriceInPips: BigNumberish;
        clientOrderId: string;
        timeInForce: BigNumberish;
        selfTradePrevention: BigNumberish;
        cancelAfter: BigNumberish;
        walletSignature: BytesLike;
      },
      {
        signatureHashVersion: BigNumberish;
        nonce: BigNumberish;
        walletAddress: string;
        orderType: BigNumberish;
        side: BigNumberish;
        quantityInPips: BigNumberish;
        quoteOrderQuantityInPips: BigNumberish;
        limitPriceInPips: BigNumberish;
        stopPriceInPips: BigNumberish;
        clientOrderId: string;
        timeInForce: BigNumberish;
        selfTradePrevention: BigNumberish;
        cancelAfter: BigNumberish;
        walletSignature: BytesLike;
      },
      {
        baseAssetSymbol: string;
        quoteAssetSymbol: string;
        baseAssetAddress: string;
        quoteAssetAddress: string;
        grossBaseQuantityInPips: BigNumberish;
        grossQuoteQuantityInPips: BigNumberish;
        netBaseQuantityInPips: BigNumberish;
        netQuoteQuantityInPips: BigNumberish;
        makerFeeAssetAddress: string;
        takerFeeAssetAddress: string;
        makerFeeQuantityInPips: BigNumberish;
        takerFeeQuantityInPips: BigNumberish;
        priceInPips: BigNumberish;
        makerSide: BigNumberish;
      },
    ],
  ): string;
  encodeFunctionData(
    functionFragment: 'registerToken',
    values: [string, string, BigNumberish],
  ): string;
  encodeFunctionData(
    functionFragment: 'confirmTokenRegistration',
    values: [string, string, BigNumberish],
  ): string;
  encodeFunctionData(
    functionFragment: 'loadAssetBySymbol',
    values: [string, BigNumberish],
  ): string;
  encodeFunctionData(
    functionFragment: 'setDispatcher',
    values: [string],
  ): string;
  encodeFunctionData(
    functionFragment: 'removeDispatcher',
    values?: undefined,
  ): string;

  decodeFunctionResult(
    functionFragment: 'removeAdmin',
    data: BytesLike,
  ): Result;
  decodeFunctionResult(functionFragment: 'setAdmin', data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: 'setCustodian',
    data: BytesLike,
  ): Result;
  decodeFunctionResult(
    functionFragment: 'setChainPropagationPeriod',
    data: BytesLike,
  ): Result;
  decodeFunctionResult(
    functionFragment: 'setFeeWallet',
    data: BytesLike,
  ): Result;
  decodeFunctionResult(
    functionFragment: 'loadBalanceInAssetUnitsByAddress',
    data: BytesLike,
  ): Result;
  decodeFunctionResult(
    functionFragment: 'loadBalanceInAssetUnitsBySymbol',
    data: BytesLike,
  ): Result;
  decodeFunctionResult(
    functionFragment: 'loadBalanceInPipsByAddress',
    data: BytesLike,
  ): Result;
  decodeFunctionResult(
    functionFragment: 'loadBalanceInPipsBySymbol',
    data: BytesLike,
  ): Result;
  decodeFunctionResult(
    functionFragment: 'loadPartiallyFilledOrderQuantityInPips',
    data: BytesLike,
  ): Result;
  decodeFunctionResult(
    functionFragment: 'depositEther',
    data: BytesLike,
  ): Result;
  decodeFunctionResult(
    functionFragment: 'depositTokenByAddress',
    data: BytesLike,
  ): Result;
  decodeFunctionResult(
    functionFragment: 'depositTokenBySymbol',
    data: BytesLike,
  ): Result;
  decodeFunctionResult(
    functionFragment: 'invalidateOrderNonce',
    data: BytesLike,
  ): Result;
  decodeFunctionResult(functionFragment: 'withdraw', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'exitWallet', data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: 'withdrawExit',
    data: BytesLike,
  ): Result;
  decodeFunctionResult(
    functionFragment: 'executeTrade',
    data: BytesLike,
  ): Result;
  decodeFunctionResult(
    functionFragment: 'registerToken',
    data: BytesLike,
  ): Result;
  decodeFunctionResult(
    functionFragment: 'confirmTokenRegistration',
    data: BytesLike,
  ): Result;
  decodeFunctionResult(
    functionFragment: 'loadAssetBySymbol',
    data: BytesLike,
  ): Result;
  decodeFunctionResult(
    functionFragment: 'setDispatcher',
    data: BytesLike,
  ): Result;
  decodeFunctionResult(
    functionFragment: 'removeDispatcher',
    data: BytesLike,
  ): Result;

  events: {
    'ChainPropagationPeriodChanged(uint256,uint256)': EventFragment;
    'Deposited(uint64,address,address,string,string,uint64,uint64,uint256)': EventFragment;
    'DispatcherChanged(address,address)': EventFragment;
    'FeeWalletChanged(address,address)': EventFragment;
    'OrderNonceInvalidated(address,uint128,uint128,uint256)': EventFragment;
    'TokenRegistered(address,string,uint8)': EventFragment;
    'TokenRegistrationConfirmed(address,string,uint8)': EventFragment;
    'TradeExecuted(address,address,string,string,string,string,uint64,uint64,uint64,bytes32,bytes32)': EventFragment;
    'WalletExitWithdrawn(address,address,string,uint64,uint64,uint256)': EventFragment;
    'WalletExited(address,uint256)': EventFragment;
    'Withdrawn(address,address,string,uint64,uint64,uint256)': EventFragment;
  };

  getEvent(
    nameOrSignatureOrTopic: 'ChainPropagationPeriodChanged',
  ): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'Deposited'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'DispatcherChanged'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'FeeWalletChanged'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'OrderNonceInvalidated'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'TokenRegistered'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'TokenRegistrationConfirmed'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'TradeExecuted'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'WalletExitWithdrawn'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'WalletExited'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'Withdrawn'): EventFragment;
}

export class Exchange extends Contract {
  connect(signerOrProvider: Signer | Provider | string): this;

  attach(addressOrName: string): this;

  deployed(): Promise<this>;

  on(event: EventFilter | string, listener: Listener): this;

  once(event: EventFilter | string, listener: Listener): this;

  addListener(eventName: EventFilter | string, listener: Listener): this;

  removeAllListeners(eventName: EventFilter | string): this;

  removeListener(eventName: any, listener: Listener): this;

  interface: ExchangeInterface;

  functions: {
    /**
     * Clears the currently whitelisted admin wallet, effectively disabling any functions requiring the admin role
     */
    removeAdmin(overrides?: Overrides): Promise<ContractTransaction>;

    /**
     * Sets a new whitelisted admin wallet
     * @param newAdmin The new whitelisted admin wallet. Must be different from the current one
     */
    setAdmin(
      newAdmin: string,
      overrides?: Overrides,
    ): Promise<ContractTransaction>;

    /**
     * The `Custodian` accepts `Exchange` and `Governance` addresses in its constructor, after which they can only be changed by the `Governance` contract itself. Therefore the `Custodian` must be deployed last and its address set here on an existing `Exchange` contract. This value is immutable once set and cannot be changed again
     * Sets the address of the `Custodian` contract
     * @param newCustodian The address of the `Custodian` contract deployed against this `Exchange` contract's address
     */
    setCustodian(
      newCustodian: string,
      overrides?: Overrides,
    ): Promise<ContractTransaction>;

    /**
     * Sets a new Chain Propagation Period - the block delay after which order nonce invalidations are respected by `executeTrade` and wallet exits are respected by `executeTrade` and `withdraw`
     * @param newChainPropagationPeriod The new Chain Propagation Period expressed as a number of blocks. Must be less than `_maxChainPropagationPeriod`
     */
    setChainPropagationPeriod(
      newChainPropagationPeriod: BigNumberish,
      overrides?: Overrides,
    ): Promise<ContractTransaction>;

    /**
     * Trade and Withdraw fees will accrue in the `_balancesInPips` mappings for this wallet
     * Sets the address of the Fee wallet
     * @param newFeeWallet The new Fee wallet. Must be different from the current one
     */
    setFeeWallet(
      newFeeWallet: string,
      overrides?: Overrides,
    ): Promise<ContractTransaction>;

    /**
     * Load a wallet's balance by asset address, in asset units
     * @param assetAddress The asset address to load the wallet's balance for
     * @param wallet The wallet address to load the balance for. Can be different from `msg.sender`
     */
    loadBalanceInAssetUnitsByAddress(
      wallet: string,
      assetAddress: string,
      overrides?: CallOverrides,
    ): Promise<{
      0: BigNumber;
    }>;

    /**
     * Load a wallet's balance by asset address, in asset units
     * @param assetSymbol The asset symbol to load the wallet's balance for
     * @param wallet The wallet address to load the balance for. Can be different from `msg.sender`
     */
    loadBalanceInAssetUnitsBySymbol(
      wallet: string,
      assetSymbol: string,
      overrides?: CallOverrides,
    ): Promise<{
      0: BigNumber;
    }>;

    /**
     * Load a wallet's balance by asset address, in pips
     * @param assetAddress The asset address to load the wallet's balance for
     * @param wallet The wallet address to load the balance for. Can be different from `msg.sender`
     */
    loadBalanceInPipsByAddress(
      wallet: string,
      assetAddress: string,
      overrides?: CallOverrides,
    ): Promise<{
      0: BigNumber;
    }>;

    /**
     * Load a wallet's balance by asset symbol, in pips
     * @param assetSymbol The asset symbol to load the wallet's balance for
     * @param wallet The wallet address to load the balance for. Can be different from `msg.sender`
     */
    loadBalanceInPipsBySymbol(
      wallet: string,
      assetSymbol: string,
      overrides?: CallOverrides,
    ): Promise<{
      0: BigNumber;
    }>;

    /**
     * Invalidating an order nonce will not clear partial fill quantities for earlier orders because the gas cost would potentially be unbound
     * Load the quantity filled so far for a partially filled orders
     * @param orderHash The order hash as originally signed by placing wallet that uniquely identifies an order
     */
    loadPartiallyFilledOrderQuantityInPips(
      orderHash: BytesLike,
      overrides?: CallOverrides,
    ): Promise<{
      0: BigNumber;
    }>;

    /**
     * Deposit ETH
     */
    depositEther(overrides?: PayableOverrides): Promise<ContractTransaction>;

    /**
     * Deposit `IERC20` compliant tokens
     * @param quantityInAssetUnits The quantity to deposit. The sending wallet must first call the `approve` method on the token contract for at least this quantity first
     * @param tokenAddress The token contract address
     */
    depositTokenByAddress(
      tokenAddress: string,
      quantityInAssetUnits: BigNumberish,
      overrides?: Overrides,
    ): Promise<ContractTransaction>;

    /**
     * Deposit `IERC20` compliant tokens
     * @param assetSymbol The case-sensitive symbol string for the token
     * @param quantityInAssetUnits The quantity to deposit. The sending wallet must first call the `approve` method on the token contract for at least this quantity first
     */
    depositTokenBySymbol(
      assetSymbol: string,
      quantityInAssetUnits: BigNumberish,
      overrides?: Overrides,
    ): Promise<ContractTransaction>;

    /**
     * Invalidate all order nonces with a timestampInMs lower than the one provided
     * @param nonce A Version 1 UUID. After calling and once the Chain Propagation Period has elapsed, `executeTrade` will reject order nonces from this wallet with a timestampInMs component lower than the one provided
     */
    invalidateOrderNonce(
      nonce: BigNumberish,
      overrides?: Overrides,
    ): Promise<ContractTransaction>;

    withdraw(
      withdrawal: {
        withdrawalType: BigNumberish;
        nonce: BigNumberish;
        walletAddress: string;
        assetSymbol: string;
        assetAddress: string;
        quantityInPips: BigNumberish;
        gasFeeInPips: BigNumberish;
        autoDispatchEnabled: boolean;
        walletSignature: BytesLike;
      },
      overrides?: Overrides,
    ): Promise<ContractTransaction>;

    /**
     * Permanently flags the sending wallet as exited, immediately disabling deposits upon mining. After the Chain Propagation Period passes trades and withdrawals are also disabled for the wallet, and assets may then be withdrawn one at a time via `withdrawExit`
     */
    exitWallet(overrides?: Overrides): Promise<ContractTransaction>;

    /**
     * Withdraw the entire balance of an asset for an exited wallet. The Chain Propagation Period must have already passed since calling `exitWallet` on `assetAddress`
     * @param assetAddress The address of the asset to withdraw
     */
    withdrawExit(
      assetAddress: string,
      overrides?: Overrides,
    ): Promise<ContractTransaction>;

    executeTrade(
      buy: {
        signatureHashVersion: BigNumberish;
        nonce: BigNumberish;
        walletAddress: string;
        orderType: BigNumberish;
        side: BigNumberish;
        quantityInPips: BigNumberish;
        quoteOrderQuantityInPips: BigNumberish;
        limitPriceInPips: BigNumberish;
        stopPriceInPips: BigNumberish;
        clientOrderId: string;
        timeInForce: BigNumberish;
        selfTradePrevention: BigNumberish;
        cancelAfter: BigNumberish;
        walletSignature: BytesLike;
      },
      sell: {
        signatureHashVersion: BigNumberish;
        nonce: BigNumberish;
        walletAddress: string;
        orderType: BigNumberish;
        side: BigNumberish;
        quantityInPips: BigNumberish;
        quoteOrderQuantityInPips: BigNumberish;
        limitPriceInPips: BigNumberish;
        stopPriceInPips: BigNumberish;
        clientOrderId: string;
        timeInForce: BigNumberish;
        selfTradePrevention: BigNumberish;
        cancelAfter: BigNumberish;
        walletSignature: BytesLike;
      },
      trade: {
        baseAssetSymbol: string;
        quoteAssetSymbol: string;
        baseAssetAddress: string;
        quoteAssetAddress: string;
        grossBaseQuantityInPips: BigNumberish;
        grossQuoteQuantityInPips: BigNumberish;
        netBaseQuantityInPips: BigNumberish;
        netQuoteQuantityInPips: BigNumberish;
        makerFeeAssetAddress: string;
        takerFeeAssetAddress: string;
        makerFeeQuantityInPips: BigNumberish;
        takerFeeQuantityInPips: BigNumberish;
        priceInPips: BigNumberish;
        makerSide: BigNumberish;
      },
      overrides?: Overrides,
    ): Promise<ContractTransaction>;

    /**
     * Initiate registration process for a token asset. Only `IERC20` compliant tokens can be added - ETH is hardcoded in the registry
     * @param decimals The decimal precision of the token
     * @param symbol The symbol identifying the token asset
     * @param tokenAddress The address of the `IERC20` compliant token contract to add
     */
    registerToken(
      tokenAddress: string,
      symbol: string,
      decimals: BigNumberish,
      overrides?: Overrides,
    ): Promise<ContractTransaction>;

    /**
     * Finalize registration process for a token asset. All parameters must exactly match a previous call to `registerToken`
     * @param decimals The decimal precision of the token
     * @param symbol The symbol identifying the token asset
     * @param tokenAddress The address of the `IERC20` compliant token contract to add
     */
    confirmTokenRegistration(
      tokenAddress: string,
      symbol: string,
      decimals: BigNumberish,
      overrides?: Overrides,
    ): Promise<ContractTransaction>;

    /**
     * Since multiple token addresses can potentially share the same symbol (in case of a token swap/contract upgrade) the provided `timestampInMs` is compared against each asset's `confirmedTimestampInMs` to uniquely determine the newest asset for the symbol at that point in time
     * Loads an asset descriptor struct by its symbol and timestamp
     * @param assetSymbol The asset's symbol
     * @param timestampInMs Point in time used to disambiguate multiple tokens with same symbol
     */
    loadAssetBySymbol(
      assetSymbol: string,
      timestampInMs: BigNumberish,
      overrides?: CallOverrides,
    ): Promise<{
      0: {
        exists: boolean;
        assetAddress: string;
        symbol: string;
        decimals: number;
        isConfirmed: boolean;
        confirmedTimestampInMs: BigNumber;
        0: boolean;
        1: string;
        2: string;
        3: number;
        4: boolean;
        5: BigNumber;
      };
    }>;

    /**
     * Sets the wallet whitelisted to dispatch transactions calling the `executeTrade` and `withdraw` functions
     * @param newDispatcherWallet The new whitelisted dispatcher wallet. Must be different from the current one
     */
    setDispatcher(
      newDispatcherWallet: string,
      overrides?: Overrides,
    ): Promise<ContractTransaction>;

    /**
     * Clears the currently set whitelisted dispatcher wallet, effectively disabling calling the `executeTrade` and `withdraw` functions until a new wallet is set with `setDispatcher`
     */
    removeDispatcher(overrides?: Overrides): Promise<ContractTransaction>;
  };

  /**
   * Clears the currently whitelisted admin wallet, effectively disabling any functions requiring the admin role
   */
  removeAdmin(overrides?: Overrides): Promise<ContractTransaction>;

  /**
   * Sets a new whitelisted admin wallet
   * @param newAdmin The new whitelisted admin wallet. Must be different from the current one
   */
  setAdmin(
    newAdmin: string,
    overrides?: Overrides,
  ): Promise<ContractTransaction>;

  /**
   * The `Custodian` accepts `Exchange` and `Governance` addresses in its constructor, after which they can only be changed by the `Governance` contract itself. Therefore the `Custodian` must be deployed last and its address set here on an existing `Exchange` contract. This value is immutable once set and cannot be changed again
   * Sets the address of the `Custodian` contract
   * @param newCustodian The address of the `Custodian` contract deployed against this `Exchange` contract's address
   */
  setCustodian(
    newCustodian: string,
    overrides?: Overrides,
  ): Promise<ContractTransaction>;

  /**
   * Sets a new Chain Propagation Period - the block delay after which order nonce invalidations are respected by `executeTrade` and wallet exits are respected by `executeTrade` and `withdraw`
   * @param newChainPropagationPeriod The new Chain Propagation Period expressed as a number of blocks. Must be less than `_maxChainPropagationPeriod`
   */
  setChainPropagationPeriod(
    newChainPropagationPeriod: BigNumberish,
    overrides?: Overrides,
  ): Promise<ContractTransaction>;

  /**
   * Trade and Withdraw fees will accrue in the `_balancesInPips` mappings for this wallet
   * Sets the address of the Fee wallet
   * @param newFeeWallet The new Fee wallet. Must be different from the current one
   */
  setFeeWallet(
    newFeeWallet: string,
    overrides?: Overrides,
  ): Promise<ContractTransaction>;

  /**
   * Load a wallet's balance by asset address, in asset units
   * @param assetAddress The asset address to load the wallet's balance for
   * @param wallet The wallet address to load the balance for. Can be different from `msg.sender`
   */
  loadBalanceInAssetUnitsByAddress(
    wallet: string,
    assetAddress: string,
    overrides?: CallOverrides,
  ): Promise<BigNumber>;

  /**
   * Load a wallet's balance by asset address, in asset units
   * @param assetSymbol The asset symbol to load the wallet's balance for
   * @param wallet The wallet address to load the balance for. Can be different from `msg.sender`
   */
  loadBalanceInAssetUnitsBySymbol(
    wallet: string,
    assetSymbol: string,
    overrides?: CallOverrides,
  ): Promise<BigNumber>;

  /**
   * Load a wallet's balance by asset address, in pips
   * @param assetAddress The asset address to load the wallet's balance for
   * @param wallet The wallet address to load the balance for. Can be different from `msg.sender`
   */
  loadBalanceInPipsByAddress(
    wallet: string,
    assetAddress: string,
    overrides?: CallOverrides,
  ): Promise<BigNumber>;

  /**
   * Load a wallet's balance by asset symbol, in pips
   * @param assetSymbol The asset symbol to load the wallet's balance for
   * @param wallet The wallet address to load the balance for. Can be different from `msg.sender`
   */
  loadBalanceInPipsBySymbol(
    wallet: string,
    assetSymbol: string,
    overrides?: CallOverrides,
  ): Promise<BigNumber>;

  /**
   * Invalidating an order nonce will not clear partial fill quantities for earlier orders because the gas cost would potentially be unbound
   * Load the quantity filled so far for a partially filled orders
   * @param orderHash The order hash as originally signed by placing wallet that uniquely identifies an order
   */
  loadPartiallyFilledOrderQuantityInPips(
    orderHash: BytesLike,
    overrides?: CallOverrides,
  ): Promise<BigNumber>;

  /**
   * Deposit ETH
   */
  depositEther(overrides?: PayableOverrides): Promise<ContractTransaction>;

  /**
   * Deposit `IERC20` compliant tokens
   * @param quantityInAssetUnits The quantity to deposit. The sending wallet must first call the `approve` method on the token contract for at least this quantity first
   * @param tokenAddress The token contract address
   */
  depositTokenByAddress(
    tokenAddress: string,
    quantityInAssetUnits: BigNumberish,
    overrides?: Overrides,
  ): Promise<ContractTransaction>;

  /**
   * Deposit `IERC20` compliant tokens
   * @param assetSymbol The case-sensitive symbol string for the token
   * @param quantityInAssetUnits The quantity to deposit. The sending wallet must first call the `approve` method on the token contract for at least this quantity first
   */
  depositTokenBySymbol(
    assetSymbol: string,
    quantityInAssetUnits: BigNumberish,
    overrides?: Overrides,
  ): Promise<ContractTransaction>;

  /**
   * Invalidate all order nonces with a timestampInMs lower than the one provided
   * @param nonce A Version 1 UUID. After calling and once the Chain Propagation Period has elapsed, `executeTrade` will reject order nonces from this wallet with a timestampInMs component lower than the one provided
   */
  invalidateOrderNonce(
    nonce: BigNumberish,
    overrides?: Overrides,
  ): Promise<ContractTransaction>;

  withdraw(
    withdrawal: {
      withdrawalType: BigNumberish;
      nonce: BigNumberish;
      walletAddress: string;
      assetSymbol: string;
      assetAddress: string;
      quantityInPips: BigNumberish;
      gasFeeInPips: BigNumberish;
      autoDispatchEnabled: boolean;
      walletSignature: BytesLike;
    },
    overrides?: Overrides,
  ): Promise<ContractTransaction>;

  /**
   * Permanently flags the sending wallet as exited, immediately disabling deposits upon mining. After the Chain Propagation Period passes trades and withdrawals are also disabled for the wallet, and assets may then be withdrawn one at a time via `withdrawExit`
   */
  exitWallet(overrides?: Overrides): Promise<ContractTransaction>;

  /**
   * Withdraw the entire balance of an asset for an exited wallet. The Chain Propagation Period must have already passed since calling `exitWallet` on `assetAddress`
   * @param assetAddress The address of the asset to withdraw
   */
  withdrawExit(
    assetAddress: string,
    overrides?: Overrides,
  ): Promise<ContractTransaction>;

  executeTrade(
    buy: {
      signatureHashVersion: BigNumberish;
      nonce: BigNumberish;
      walletAddress: string;
      orderType: BigNumberish;
      side: BigNumberish;
      quantityInPips: BigNumberish;
      quoteOrderQuantityInPips: BigNumberish;
      limitPriceInPips: BigNumberish;
      stopPriceInPips: BigNumberish;
      clientOrderId: string;
      timeInForce: BigNumberish;
      selfTradePrevention: BigNumberish;
      cancelAfter: BigNumberish;
      walletSignature: BytesLike;
    },
    sell: {
      signatureHashVersion: BigNumberish;
      nonce: BigNumberish;
      walletAddress: string;
      orderType: BigNumberish;
      side: BigNumberish;
      quantityInPips: BigNumberish;
      quoteOrderQuantityInPips: BigNumberish;
      limitPriceInPips: BigNumberish;
      stopPriceInPips: BigNumberish;
      clientOrderId: string;
      timeInForce: BigNumberish;
      selfTradePrevention: BigNumberish;
      cancelAfter: BigNumberish;
      walletSignature: BytesLike;
    },
    trade: {
      baseAssetSymbol: string;
      quoteAssetSymbol: string;
      baseAssetAddress: string;
      quoteAssetAddress: string;
      grossBaseQuantityInPips: BigNumberish;
      grossQuoteQuantityInPips: BigNumberish;
      netBaseQuantityInPips: BigNumberish;
      netQuoteQuantityInPips: BigNumberish;
      makerFeeAssetAddress: string;
      takerFeeAssetAddress: string;
      makerFeeQuantityInPips: BigNumberish;
      takerFeeQuantityInPips: BigNumberish;
      priceInPips: BigNumberish;
      makerSide: BigNumberish;
    },
    overrides?: Overrides,
  ): Promise<ContractTransaction>;

  /**
   * Initiate registration process for a token asset. Only `IERC20` compliant tokens can be added - ETH is hardcoded in the registry
   * @param decimals The decimal precision of the token
   * @param symbol The symbol identifying the token asset
   * @param tokenAddress The address of the `IERC20` compliant token contract to add
   */
  registerToken(
    tokenAddress: string,
    symbol: string,
    decimals: BigNumberish,
    overrides?: Overrides,
  ): Promise<ContractTransaction>;

  /**
   * Finalize registration process for a token asset. All parameters must exactly match a previous call to `registerToken`
   * @param decimals The decimal precision of the token
   * @param symbol The symbol identifying the token asset
   * @param tokenAddress The address of the `IERC20` compliant token contract to add
   */
  confirmTokenRegistration(
    tokenAddress: string,
    symbol: string,
    decimals: BigNumberish,
    overrides?: Overrides,
  ): Promise<ContractTransaction>;

  /**
   * Since multiple token addresses can potentially share the same symbol (in case of a token swap/contract upgrade) the provided `timestampInMs` is compared against each asset's `confirmedTimestampInMs` to uniquely determine the newest asset for the symbol at that point in time
   * Loads an asset descriptor struct by its symbol and timestamp
   * @param assetSymbol The asset's symbol
   * @param timestampInMs Point in time used to disambiguate multiple tokens with same symbol
   */
  loadAssetBySymbol(
    assetSymbol: string,
    timestampInMs: BigNumberish,
    overrides?: CallOverrides,
  ): Promise<{
    exists: boolean;
    assetAddress: string;
    symbol: string;
    decimals: number;
    isConfirmed: boolean;
    confirmedTimestampInMs: BigNumber;
    0: boolean;
    1: string;
    2: string;
    3: number;
    4: boolean;
    5: BigNumber;
  }>;

  /**
   * Sets the wallet whitelisted to dispatch transactions calling the `executeTrade` and `withdraw` functions
   * @param newDispatcherWallet The new whitelisted dispatcher wallet. Must be different from the current one
   */
  setDispatcher(
    newDispatcherWallet: string,
    overrides?: Overrides,
  ): Promise<ContractTransaction>;

  /**
   * Clears the currently set whitelisted dispatcher wallet, effectively disabling calling the `executeTrade` and `withdraw` functions until a new wallet is set with `setDispatcher`
   */
  removeDispatcher(overrides?: Overrides): Promise<ContractTransaction>;

  callStatic: {
    /**
     * Clears the currently whitelisted admin wallet, effectively disabling any functions requiring the admin role
     */
    removeAdmin(overrides?: Overrides): Promise<void>;

    /**
     * Sets a new whitelisted admin wallet
     * @param newAdmin The new whitelisted admin wallet. Must be different from the current one
     */
    setAdmin(newAdmin: string, overrides?: Overrides): Promise<void>;

    /**
     * The `Custodian` accepts `Exchange` and `Governance` addresses in its constructor, after which they can only be changed by the `Governance` contract itself. Therefore the `Custodian` must be deployed last and its address set here on an existing `Exchange` contract. This value is immutable once set and cannot be changed again
     * Sets the address of the `Custodian` contract
     * @param newCustodian The address of the `Custodian` contract deployed against this `Exchange` contract's address
     */
    setCustodian(newCustodian: string, overrides?: Overrides): Promise<void>;

    /**
     * Sets a new Chain Propagation Period - the block delay after which order nonce invalidations are respected by `executeTrade` and wallet exits are respected by `executeTrade` and `withdraw`
     * @param newChainPropagationPeriod The new Chain Propagation Period expressed as a number of blocks. Must be less than `_maxChainPropagationPeriod`
     */
    setChainPropagationPeriod(
      newChainPropagationPeriod: BigNumberish,
      overrides?: Overrides,
    ): Promise<void>;

    /**
     * Trade and Withdraw fees will accrue in the `_balancesInPips` mappings for this wallet
     * Sets the address of the Fee wallet
     * @param newFeeWallet The new Fee wallet. Must be different from the current one
     */
    setFeeWallet(newFeeWallet: string, overrides?: Overrides): Promise<void>;

    /**
     * Load a wallet's balance by asset address, in asset units
     * @param assetAddress The asset address to load the wallet's balance for
     * @param wallet The wallet address to load the balance for. Can be different from `msg.sender`
     */
    loadBalanceInAssetUnitsByAddress(
      wallet: string,
      assetAddress: string,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    /**
     * Load a wallet's balance by asset address, in asset units
     * @param assetSymbol The asset symbol to load the wallet's balance for
     * @param wallet The wallet address to load the balance for. Can be different from `msg.sender`
     */
    loadBalanceInAssetUnitsBySymbol(
      wallet: string,
      assetSymbol: string,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    /**
     * Load a wallet's balance by asset address, in pips
     * @param assetAddress The asset address to load the wallet's balance for
     * @param wallet The wallet address to load the balance for. Can be different from `msg.sender`
     */
    loadBalanceInPipsByAddress(
      wallet: string,
      assetAddress: string,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    /**
     * Load a wallet's balance by asset symbol, in pips
     * @param assetSymbol The asset symbol to load the wallet's balance for
     * @param wallet The wallet address to load the balance for. Can be different from `msg.sender`
     */
    loadBalanceInPipsBySymbol(
      wallet: string,
      assetSymbol: string,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    /**
     * Invalidating an order nonce will not clear partial fill quantities for earlier orders because the gas cost would potentially be unbound
     * Load the quantity filled so far for a partially filled orders
     * @param orderHash The order hash as originally signed by placing wallet that uniquely identifies an order
     */
    loadPartiallyFilledOrderQuantityInPips(
      orderHash: BytesLike,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    /**
     * Deposit ETH
     */
    depositEther(overrides?: PayableOverrides): Promise<void>;

    /**
     * Deposit `IERC20` compliant tokens
     * @param quantityInAssetUnits The quantity to deposit. The sending wallet must first call the `approve` method on the token contract for at least this quantity first
     * @param tokenAddress The token contract address
     */
    depositTokenByAddress(
      tokenAddress: string,
      quantityInAssetUnits: BigNumberish,
      overrides?: Overrides,
    ): Promise<void>;

    /**
     * Deposit `IERC20` compliant tokens
     * @param assetSymbol The case-sensitive symbol string for the token
     * @param quantityInAssetUnits The quantity to deposit. The sending wallet must first call the `approve` method on the token contract for at least this quantity first
     */
    depositTokenBySymbol(
      assetSymbol: string,
      quantityInAssetUnits: BigNumberish,
      overrides?: Overrides,
    ): Promise<void>;

    /**
     * Invalidate all order nonces with a timestampInMs lower than the one provided
     * @param nonce A Version 1 UUID. After calling and once the Chain Propagation Period has elapsed, `executeTrade` will reject order nonces from this wallet with a timestampInMs component lower than the one provided
     */
    invalidateOrderNonce(
      nonce: BigNumberish,
      overrides?: Overrides,
    ): Promise<void>;

    withdraw(
      withdrawal: {
        withdrawalType: BigNumberish;
        nonce: BigNumberish;
        walletAddress: string;
        assetSymbol: string;
        assetAddress: string;
        quantityInPips: BigNumberish;
        gasFeeInPips: BigNumberish;
        autoDispatchEnabled: boolean;
        walletSignature: BytesLike;
      },
      overrides?: Overrides,
    ): Promise<void>;

    /**
     * Permanently flags the sending wallet as exited, immediately disabling deposits upon mining. After the Chain Propagation Period passes trades and withdrawals are also disabled for the wallet, and assets may then be withdrawn one at a time via `withdrawExit`
     */
    exitWallet(overrides?: Overrides): Promise<void>;

    /**
     * Withdraw the entire balance of an asset for an exited wallet. The Chain Propagation Period must have already passed since calling `exitWallet` on `assetAddress`
     * @param assetAddress The address of the asset to withdraw
     */
    withdrawExit(assetAddress: string, overrides?: Overrides): Promise<void>;

    executeTrade(
      buy: {
        signatureHashVersion: BigNumberish;
        nonce: BigNumberish;
        walletAddress: string;
        orderType: BigNumberish;
        side: BigNumberish;
        quantityInPips: BigNumberish;
        quoteOrderQuantityInPips: BigNumberish;
        limitPriceInPips: BigNumberish;
        stopPriceInPips: BigNumberish;
        clientOrderId: string;
        timeInForce: BigNumberish;
        selfTradePrevention: BigNumberish;
        cancelAfter: BigNumberish;
        walletSignature: BytesLike;
      },
      sell: {
        signatureHashVersion: BigNumberish;
        nonce: BigNumberish;
        walletAddress: string;
        orderType: BigNumberish;
        side: BigNumberish;
        quantityInPips: BigNumberish;
        quoteOrderQuantityInPips: BigNumberish;
        limitPriceInPips: BigNumberish;
        stopPriceInPips: BigNumberish;
        clientOrderId: string;
        timeInForce: BigNumberish;
        selfTradePrevention: BigNumberish;
        cancelAfter: BigNumberish;
        walletSignature: BytesLike;
      },
      trade: {
        baseAssetSymbol: string;
        quoteAssetSymbol: string;
        baseAssetAddress: string;
        quoteAssetAddress: string;
        grossBaseQuantityInPips: BigNumberish;
        grossQuoteQuantityInPips: BigNumberish;
        netBaseQuantityInPips: BigNumberish;
        netQuoteQuantityInPips: BigNumberish;
        makerFeeAssetAddress: string;
        takerFeeAssetAddress: string;
        makerFeeQuantityInPips: BigNumberish;
        takerFeeQuantityInPips: BigNumberish;
        priceInPips: BigNumberish;
        makerSide: BigNumberish;
      },
      overrides?: Overrides,
    ): Promise<void>;

    /**
     * Initiate registration process for a token asset. Only `IERC20` compliant tokens can be added - ETH is hardcoded in the registry
     * @param decimals The decimal precision of the token
     * @param symbol The symbol identifying the token asset
     * @param tokenAddress The address of the `IERC20` compliant token contract to add
     */
    registerToken(
      tokenAddress: string,
      symbol: string,
      decimals: BigNumberish,
      overrides?: Overrides,
    ): Promise<void>;

    /**
     * Finalize registration process for a token asset. All parameters must exactly match a previous call to `registerToken`
     * @param decimals The decimal precision of the token
     * @param symbol The symbol identifying the token asset
     * @param tokenAddress The address of the `IERC20` compliant token contract to add
     */
    confirmTokenRegistration(
      tokenAddress: string,
      symbol: string,
      decimals: BigNumberish,
      overrides?: Overrides,
    ): Promise<void>;

    /**
     * Since multiple token addresses can potentially share the same symbol (in case of a token swap/contract upgrade) the provided `timestampInMs` is compared against each asset's `confirmedTimestampInMs` to uniquely determine the newest asset for the symbol at that point in time
     * Loads an asset descriptor struct by its symbol and timestamp
     * @param assetSymbol The asset's symbol
     * @param timestampInMs Point in time used to disambiguate multiple tokens with same symbol
     */
    loadAssetBySymbol(
      assetSymbol: string,
      timestampInMs: BigNumberish,
      overrides?: CallOverrides,
    ): Promise<{
      exists: boolean;
      assetAddress: string;
      symbol: string;
      decimals: number;
      isConfirmed: boolean;
      confirmedTimestampInMs: BigNumber;
      0: boolean;
      1: string;
      2: string;
      3: number;
      4: boolean;
      5: BigNumber;
    }>;

    /**
     * Sets the wallet whitelisted to dispatch transactions calling the `executeTrade` and `withdraw` functions
     * @param newDispatcherWallet The new whitelisted dispatcher wallet. Must be different from the current one
     */
    setDispatcher(
      newDispatcherWallet: string,
      overrides?: Overrides,
    ): Promise<void>;

    /**
     * Clears the currently set whitelisted dispatcher wallet, effectively disabling calling the `executeTrade` and `withdraw` functions until a new wallet is set with `setDispatcher`
     */
    removeDispatcher(overrides?: Overrides): Promise<void>;
  };

  filters: {
    ChainPropagationPeriodChanged(
      previousValue: null,
      newValue: null,
    ): EventFilter;

    Deposited(
      index: null,
      wallet: string | null,
      assetAddress: string | null,
      assetSymbolIndex: string | null,
      assetSymbol: null,
      quantityInPips: null,
      newExchangeBalanceInPips: null,
      newExchangeBalanceInAssetUnits: null,
    ): EventFilter;

    DispatcherChanged(previousValue: null, newValue: null): EventFilter;

    FeeWalletChanged(previousValue: null, newValue: null): EventFilter;

    OrderNonceInvalidated(
      wallet: string | null,
      nonce: null,
      timestampInMs: null,
      effectiveBlockNumber: null,
    ): EventFilter;

    TokenRegistered(
      assetAddress: string | null,
      assetSymbol: null,
      decimals: null,
    ): EventFilter;

    TokenRegistrationConfirmed(
      assetAddress: string | null,
      assetSymbol: null,
      decimals: null,
    ): EventFilter;

    TradeExecuted(
      buyWallet: null,
      sellWallet: null,
      baseAssetSymbolIndex: string | null,
      quoteAssetSymbolIndex: string | null,
      baseAssetSymbol: null,
      quoteAssetSymbol: null,
      baseQuantityInPips: null,
      quoteQuantityInPips: null,
      tradePriceInPips: null,
      buyOrderHash: null,
      sellOrderHash: null,
    ): EventFilter;

    WalletExitWithdrawn(
      wallet: string | null,
      assetAddress: string | null,
      assetSymbol: null,
      quantityInPips: null,
      newExchangeBalanceInPips: null,
      newExchangeBalanceInAssetUnits: null,
    ): EventFilter;

    WalletExited(
      wallet: string | null,
      effectiveBlockNumber: null,
    ): EventFilter;

    Withdrawn(
      wallet: string | null,
      assetAddress: string | null,
      assetSymbol: null,
      quantityInPips: null,
      newExchangeBalanceInPips: null,
      newExchangeBalanceInAssetUnits: null,
    ): EventFilter;
  };

  estimateGas: {
    /**
     * Clears the currently whitelisted admin wallet, effectively disabling any functions requiring the admin role
     */
    removeAdmin(overrides?: Overrides): Promise<BigNumber>;

    /**
     * Sets a new whitelisted admin wallet
     * @param newAdmin The new whitelisted admin wallet. Must be different from the current one
     */
    setAdmin(newAdmin: string, overrides?: Overrides): Promise<BigNumber>;

    /**
     * The `Custodian` accepts `Exchange` and `Governance` addresses in its constructor, after which they can only be changed by the `Governance` contract itself. Therefore the `Custodian` must be deployed last and its address set here on an existing `Exchange` contract. This value is immutable once set and cannot be changed again
     * Sets the address of the `Custodian` contract
     * @param newCustodian The address of the `Custodian` contract deployed against this `Exchange` contract's address
     */
    setCustodian(
      newCustodian: string,
      overrides?: Overrides,
    ): Promise<BigNumber>;

    /**
     * Sets a new Chain Propagation Period - the block delay after which order nonce invalidations are respected by `executeTrade` and wallet exits are respected by `executeTrade` and `withdraw`
     * @param newChainPropagationPeriod The new Chain Propagation Period expressed as a number of blocks. Must be less than `_maxChainPropagationPeriod`
     */
    setChainPropagationPeriod(
      newChainPropagationPeriod: BigNumberish,
      overrides?: Overrides,
    ): Promise<BigNumber>;

    /**
     * Trade and Withdraw fees will accrue in the `_balancesInPips` mappings for this wallet
     * Sets the address of the Fee wallet
     * @param newFeeWallet The new Fee wallet. Must be different from the current one
     */
    setFeeWallet(
      newFeeWallet: string,
      overrides?: Overrides,
    ): Promise<BigNumber>;

    /**
     * Load a wallet's balance by asset address, in asset units
     * @param assetAddress The asset address to load the wallet's balance for
     * @param wallet The wallet address to load the balance for. Can be different from `msg.sender`
     */
    loadBalanceInAssetUnitsByAddress(
      wallet: string,
      assetAddress: string,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    /**
     * Load a wallet's balance by asset address, in asset units
     * @param assetSymbol The asset symbol to load the wallet's balance for
     * @param wallet The wallet address to load the balance for. Can be different from `msg.sender`
     */
    loadBalanceInAssetUnitsBySymbol(
      wallet: string,
      assetSymbol: string,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    /**
     * Load a wallet's balance by asset address, in pips
     * @param assetAddress The asset address to load the wallet's balance for
     * @param wallet The wallet address to load the balance for. Can be different from `msg.sender`
     */
    loadBalanceInPipsByAddress(
      wallet: string,
      assetAddress: string,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    /**
     * Load a wallet's balance by asset symbol, in pips
     * @param assetSymbol The asset symbol to load the wallet's balance for
     * @param wallet The wallet address to load the balance for. Can be different from `msg.sender`
     */
    loadBalanceInPipsBySymbol(
      wallet: string,
      assetSymbol: string,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    /**
     * Invalidating an order nonce will not clear partial fill quantities for earlier orders because the gas cost would potentially be unbound
     * Load the quantity filled so far for a partially filled orders
     * @param orderHash The order hash as originally signed by placing wallet that uniquely identifies an order
     */
    loadPartiallyFilledOrderQuantityInPips(
      orderHash: BytesLike,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    /**
     * Deposit ETH
     */
    depositEther(overrides?: PayableOverrides): Promise<BigNumber>;

    /**
     * Deposit `IERC20` compliant tokens
     * @param quantityInAssetUnits The quantity to deposit. The sending wallet must first call the `approve` method on the token contract for at least this quantity first
     * @param tokenAddress The token contract address
     */
    depositTokenByAddress(
      tokenAddress: string,
      quantityInAssetUnits: BigNumberish,
      overrides?: Overrides,
    ): Promise<BigNumber>;

    /**
     * Deposit `IERC20` compliant tokens
     * @param assetSymbol The case-sensitive symbol string for the token
     * @param quantityInAssetUnits The quantity to deposit. The sending wallet must first call the `approve` method on the token contract for at least this quantity first
     */
    depositTokenBySymbol(
      assetSymbol: string,
      quantityInAssetUnits: BigNumberish,
      overrides?: Overrides,
    ): Promise<BigNumber>;

    /**
     * Invalidate all order nonces with a timestampInMs lower than the one provided
     * @param nonce A Version 1 UUID. After calling and once the Chain Propagation Period has elapsed, `executeTrade` will reject order nonces from this wallet with a timestampInMs component lower than the one provided
     */
    invalidateOrderNonce(
      nonce: BigNumberish,
      overrides?: Overrides,
    ): Promise<BigNumber>;

    withdraw(
      withdrawal: {
        withdrawalType: BigNumberish;
        nonce: BigNumberish;
        walletAddress: string;
        assetSymbol: string;
        assetAddress: string;
        quantityInPips: BigNumberish;
        gasFeeInPips: BigNumberish;
        autoDispatchEnabled: boolean;
        walletSignature: BytesLike;
      },
      overrides?: Overrides,
    ): Promise<BigNumber>;

    /**
     * Permanently flags the sending wallet as exited, immediately disabling deposits upon mining. After the Chain Propagation Period passes trades and withdrawals are also disabled for the wallet, and assets may then be withdrawn one at a time via `withdrawExit`
     */
    exitWallet(overrides?: Overrides): Promise<BigNumber>;

    /**
     * Withdraw the entire balance of an asset for an exited wallet. The Chain Propagation Period must have already passed since calling `exitWallet` on `assetAddress`
     * @param assetAddress The address of the asset to withdraw
     */
    withdrawExit(
      assetAddress: string,
      overrides?: Overrides,
    ): Promise<BigNumber>;

    executeTrade(
      buy: {
        signatureHashVersion: BigNumberish;
        nonce: BigNumberish;
        walletAddress: string;
        orderType: BigNumberish;
        side: BigNumberish;
        quantityInPips: BigNumberish;
        quoteOrderQuantityInPips: BigNumberish;
        limitPriceInPips: BigNumberish;
        stopPriceInPips: BigNumberish;
        clientOrderId: string;
        timeInForce: BigNumberish;
        selfTradePrevention: BigNumberish;
        cancelAfter: BigNumberish;
        walletSignature: BytesLike;
      },
      sell: {
        signatureHashVersion: BigNumberish;
        nonce: BigNumberish;
        walletAddress: string;
        orderType: BigNumberish;
        side: BigNumberish;
        quantityInPips: BigNumberish;
        quoteOrderQuantityInPips: BigNumberish;
        limitPriceInPips: BigNumberish;
        stopPriceInPips: BigNumberish;
        clientOrderId: string;
        timeInForce: BigNumberish;
        selfTradePrevention: BigNumberish;
        cancelAfter: BigNumberish;
        walletSignature: BytesLike;
      },
      trade: {
        baseAssetSymbol: string;
        quoteAssetSymbol: string;
        baseAssetAddress: string;
        quoteAssetAddress: string;
        grossBaseQuantityInPips: BigNumberish;
        grossQuoteQuantityInPips: BigNumberish;
        netBaseQuantityInPips: BigNumberish;
        netQuoteQuantityInPips: BigNumberish;
        makerFeeAssetAddress: string;
        takerFeeAssetAddress: string;
        makerFeeQuantityInPips: BigNumberish;
        takerFeeQuantityInPips: BigNumberish;
        priceInPips: BigNumberish;
        makerSide: BigNumberish;
      },
      overrides?: Overrides,
    ): Promise<BigNumber>;

    /**
     * Initiate registration process for a token asset. Only `IERC20` compliant tokens can be added - ETH is hardcoded in the registry
     * @param decimals The decimal precision of the token
     * @param symbol The symbol identifying the token asset
     * @param tokenAddress The address of the `IERC20` compliant token contract to add
     */
    registerToken(
      tokenAddress: string,
      symbol: string,
      decimals: BigNumberish,
      overrides?: Overrides,
    ): Promise<BigNumber>;

    /**
     * Finalize registration process for a token asset. All parameters must exactly match a previous call to `registerToken`
     * @param decimals The decimal precision of the token
     * @param symbol The symbol identifying the token asset
     * @param tokenAddress The address of the `IERC20` compliant token contract to add
     */
    confirmTokenRegistration(
      tokenAddress: string,
      symbol: string,
      decimals: BigNumberish,
      overrides?: Overrides,
    ): Promise<BigNumber>;

    /**
     * Since multiple token addresses can potentially share the same symbol (in case of a token swap/contract upgrade) the provided `timestampInMs` is compared against each asset's `confirmedTimestampInMs` to uniquely determine the newest asset for the symbol at that point in time
     * Loads an asset descriptor struct by its symbol and timestamp
     * @param assetSymbol The asset's symbol
     * @param timestampInMs Point in time used to disambiguate multiple tokens with same symbol
     */
    loadAssetBySymbol(
      assetSymbol: string,
      timestampInMs: BigNumberish,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    /**
     * Sets the wallet whitelisted to dispatch transactions calling the `executeTrade` and `withdraw` functions
     * @param newDispatcherWallet The new whitelisted dispatcher wallet. Must be different from the current one
     */
    setDispatcher(
      newDispatcherWallet: string,
      overrides?: Overrides,
    ): Promise<BigNumber>;

    /**
     * Clears the currently set whitelisted dispatcher wallet, effectively disabling calling the `executeTrade` and `withdraw` functions until a new wallet is set with `setDispatcher`
     */
    removeDispatcher(overrides?: Overrides): Promise<BigNumber>;
  };

  populateTransaction: {
    /**
     * Clears the currently whitelisted admin wallet, effectively disabling any functions requiring the admin role
     */
    removeAdmin(overrides?: Overrides): Promise<PopulatedTransaction>;

    /**
     * Sets a new whitelisted admin wallet
     * @param newAdmin The new whitelisted admin wallet. Must be different from the current one
     */
    setAdmin(
      newAdmin: string,
      overrides?: Overrides,
    ): Promise<PopulatedTransaction>;

    /**
     * The `Custodian` accepts `Exchange` and `Governance` addresses in its constructor, after which they can only be changed by the `Governance` contract itself. Therefore the `Custodian` must be deployed last and its address set here on an existing `Exchange` contract. This value is immutable once set and cannot be changed again
     * Sets the address of the `Custodian` contract
     * @param newCustodian The address of the `Custodian` contract deployed against this `Exchange` contract's address
     */
    setCustodian(
      newCustodian: string,
      overrides?: Overrides,
    ): Promise<PopulatedTransaction>;

    /**
     * Sets a new Chain Propagation Period - the block delay after which order nonce invalidations are respected by `executeTrade` and wallet exits are respected by `executeTrade` and `withdraw`
     * @param newChainPropagationPeriod The new Chain Propagation Period expressed as a number of blocks. Must be less than `_maxChainPropagationPeriod`
     */
    setChainPropagationPeriod(
      newChainPropagationPeriod: BigNumberish,
      overrides?: Overrides,
    ): Promise<PopulatedTransaction>;

    /**
     * Trade and Withdraw fees will accrue in the `_balancesInPips` mappings for this wallet
     * Sets the address of the Fee wallet
     * @param newFeeWallet The new Fee wallet. Must be different from the current one
     */
    setFeeWallet(
      newFeeWallet: string,
      overrides?: Overrides,
    ): Promise<PopulatedTransaction>;

    /**
     * Load a wallet's balance by asset address, in asset units
     * @param assetAddress The asset address to load the wallet's balance for
     * @param wallet The wallet address to load the balance for. Can be different from `msg.sender`
     */
    loadBalanceInAssetUnitsByAddress(
      wallet: string,
      assetAddress: string,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    /**
     * Load a wallet's balance by asset address, in asset units
     * @param assetSymbol The asset symbol to load the wallet's balance for
     * @param wallet The wallet address to load the balance for. Can be different from `msg.sender`
     */
    loadBalanceInAssetUnitsBySymbol(
      wallet: string,
      assetSymbol: string,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    /**
     * Load a wallet's balance by asset address, in pips
     * @param assetAddress The asset address to load the wallet's balance for
     * @param wallet The wallet address to load the balance for. Can be different from `msg.sender`
     */
    loadBalanceInPipsByAddress(
      wallet: string,
      assetAddress: string,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    /**
     * Load a wallet's balance by asset symbol, in pips
     * @param assetSymbol The asset symbol to load the wallet's balance for
     * @param wallet The wallet address to load the balance for. Can be different from `msg.sender`
     */
    loadBalanceInPipsBySymbol(
      wallet: string,
      assetSymbol: string,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    /**
     * Invalidating an order nonce will not clear partial fill quantities for earlier orders because the gas cost would potentially be unbound
     * Load the quantity filled so far for a partially filled orders
     * @param orderHash The order hash as originally signed by placing wallet that uniquely identifies an order
     */
    loadPartiallyFilledOrderQuantityInPips(
      orderHash: BytesLike,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    /**
     * Deposit ETH
     */
    depositEther(overrides?: PayableOverrides): Promise<PopulatedTransaction>;

    /**
     * Deposit `IERC20` compliant tokens
     * @param quantityInAssetUnits The quantity to deposit. The sending wallet must first call the `approve` method on the token contract for at least this quantity first
     * @param tokenAddress The token contract address
     */
    depositTokenByAddress(
      tokenAddress: string,
      quantityInAssetUnits: BigNumberish,
      overrides?: Overrides,
    ): Promise<PopulatedTransaction>;

    /**
     * Deposit `IERC20` compliant tokens
     * @param assetSymbol The case-sensitive symbol string for the token
     * @param quantityInAssetUnits The quantity to deposit. The sending wallet must first call the `approve` method on the token contract for at least this quantity first
     */
    depositTokenBySymbol(
      assetSymbol: string,
      quantityInAssetUnits: BigNumberish,
      overrides?: Overrides,
    ): Promise<PopulatedTransaction>;

    /**
     * Invalidate all order nonces with a timestampInMs lower than the one provided
     * @param nonce A Version 1 UUID. After calling and once the Chain Propagation Period has elapsed, `executeTrade` will reject order nonces from this wallet with a timestampInMs component lower than the one provided
     */
    invalidateOrderNonce(
      nonce: BigNumberish,
      overrides?: Overrides,
    ): Promise<PopulatedTransaction>;

    withdraw(
      withdrawal: {
        withdrawalType: BigNumberish;
        nonce: BigNumberish;
        walletAddress: string;
        assetSymbol: string;
        assetAddress: string;
        quantityInPips: BigNumberish;
        gasFeeInPips: BigNumberish;
        autoDispatchEnabled: boolean;
        walletSignature: BytesLike;
      },
      overrides?: Overrides,
    ): Promise<PopulatedTransaction>;

    /**
     * Permanently flags the sending wallet as exited, immediately disabling deposits upon mining. After the Chain Propagation Period passes trades and withdrawals are also disabled for the wallet, and assets may then be withdrawn one at a time via `withdrawExit`
     */
    exitWallet(overrides?: Overrides): Promise<PopulatedTransaction>;

    /**
     * Withdraw the entire balance of an asset for an exited wallet. The Chain Propagation Period must have already passed since calling `exitWallet` on `assetAddress`
     * @param assetAddress The address of the asset to withdraw
     */
    withdrawExit(
      assetAddress: string,
      overrides?: Overrides,
    ): Promise<PopulatedTransaction>;

    executeTrade(
      buy: {
        signatureHashVersion: BigNumberish;
        nonce: BigNumberish;
        walletAddress: string;
        orderType: BigNumberish;
        side: BigNumberish;
        quantityInPips: BigNumberish;
        quoteOrderQuantityInPips: BigNumberish;
        limitPriceInPips: BigNumberish;
        stopPriceInPips: BigNumberish;
        clientOrderId: string;
        timeInForce: BigNumberish;
        selfTradePrevention: BigNumberish;
        cancelAfter: BigNumberish;
        walletSignature: BytesLike;
      },
      sell: {
        signatureHashVersion: BigNumberish;
        nonce: BigNumberish;
        walletAddress: string;
        orderType: BigNumberish;
        side: BigNumberish;
        quantityInPips: BigNumberish;
        quoteOrderQuantityInPips: BigNumberish;
        limitPriceInPips: BigNumberish;
        stopPriceInPips: BigNumberish;
        clientOrderId: string;
        timeInForce: BigNumberish;
        selfTradePrevention: BigNumberish;
        cancelAfter: BigNumberish;
        walletSignature: BytesLike;
      },
      trade: {
        baseAssetSymbol: string;
        quoteAssetSymbol: string;
        baseAssetAddress: string;
        quoteAssetAddress: string;
        grossBaseQuantityInPips: BigNumberish;
        grossQuoteQuantityInPips: BigNumberish;
        netBaseQuantityInPips: BigNumberish;
        netQuoteQuantityInPips: BigNumberish;
        makerFeeAssetAddress: string;
        takerFeeAssetAddress: string;
        makerFeeQuantityInPips: BigNumberish;
        takerFeeQuantityInPips: BigNumberish;
        priceInPips: BigNumberish;
        makerSide: BigNumberish;
      },
      overrides?: Overrides,
    ): Promise<PopulatedTransaction>;

    /**
     * Initiate registration process for a token asset. Only `IERC20` compliant tokens can be added - ETH is hardcoded in the registry
     * @param decimals The decimal precision of the token
     * @param symbol The symbol identifying the token asset
     * @param tokenAddress The address of the `IERC20` compliant token contract to add
     */
    registerToken(
      tokenAddress: string,
      symbol: string,
      decimals: BigNumberish,
      overrides?: Overrides,
    ): Promise<PopulatedTransaction>;

    /**
     * Finalize registration process for a token asset. All parameters must exactly match a previous call to `registerToken`
     * @param decimals The decimal precision of the token
     * @param symbol The symbol identifying the token asset
     * @param tokenAddress The address of the `IERC20` compliant token contract to add
     */
    confirmTokenRegistration(
      tokenAddress: string,
      symbol: string,
      decimals: BigNumberish,
      overrides?: Overrides,
    ): Promise<PopulatedTransaction>;

    /**
     * Since multiple token addresses can potentially share the same symbol (in case of a token swap/contract upgrade) the provided `timestampInMs` is compared against each asset's `confirmedTimestampInMs` to uniquely determine the newest asset for the symbol at that point in time
     * Loads an asset descriptor struct by its symbol and timestamp
     * @param assetSymbol The asset's symbol
     * @param timestampInMs Point in time used to disambiguate multiple tokens with same symbol
     */
    loadAssetBySymbol(
      assetSymbol: string,
      timestampInMs: BigNumberish,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    /**
     * Sets the wallet whitelisted to dispatch transactions calling the `executeTrade` and `withdraw` functions
     * @param newDispatcherWallet The new whitelisted dispatcher wallet. Must be different from the current one
     */
    setDispatcher(
      newDispatcherWallet: string,
      overrides?: Overrides,
    ): Promise<PopulatedTransaction>;

    /**
     * Clears the currently set whitelisted dispatcher wallet, effectively disabling calling the `executeTrade` and `withdraw` functions until a new wallet is set with `setDispatcher`
     */
    removeDispatcher(overrides?: Overrides): Promise<PopulatedTransaction>;
  };
}
